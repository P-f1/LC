/*
 * Copyright Â© 2019. TIBCO Software Inc.
 * This file is subject to the license terms contained
 * in the license file that is distributed with this file.
 */
package facetracker

import (
	"errors"
	"image"
	"image/color"
	"io"
	"math"
	"os/exec"
	"strconv"
	"sync"

	"gocv.io/x/gocv"

	"github.com/P-f1/LC/flogo-lib/core/activity"
	"github.com/P-f1/LC/flogo-lib/core/data"
	"github.com/P-f1/LC/flogo-lib/logger"
	"github.com/P-f1/LC/labs-mr4r/lib/flogobot"
	"github.com/P-f1/LC/labs-mr4r/lib/flogobot/factory"
	"github.com/P-f1/LC/labs-mr4r/lib/tello"
	"github.com/P-f1/LC/labs-mr4r/lib/util"
)

var log = logger.GetLogger("activity-tello-facetracker")

const (
	frameX    = 960
	frameY    = 720
	frameSize = frameX * frameY * 3
)

const (
	cConnection     = "Connection"
	cConnectionName = "name"
	input           = "Data"
)

var ()

type FaceTracker struct {
	metadata        *activity.Metadata
	activityToDrone map[string]tello.Drone
	mux             sync.Mutex
	imageIn         io.WriteCloser
	imageOut        io.ReadCloser
	img             gocv.Mat
	net             *gocv.Net
	// tracking
	tracking                 bool
	detected                 bool
	detectSize               bool
	green                    color.RGBA
	distTolerance            float64
	refDistance              float64
	left, top, right, bottom float64
	// ready commands
	commands []tello.Command
}

func NewActivity(metadata *activity.Metadata) activity.Activity {
	var imgProcessor FaceTracker
	ffmpeg := exec.Command("/Applications/ffmpeg", "-hwaccel", "auto", "-hwaccel_device", "opencl", "-i", "pipe:0",
		"-pix_fmt", "bgr24", "-s", strconv.Itoa(frameX)+"x"+strconv.Itoa(frameY), "-f", "rawvideo", "pipe:1")
	imageIn, _ := ffmpeg.StdinPipe()
	imageOut, _ := ffmpeg.StdoutPipe()
	if err := ffmpeg.Start(); err != nil {
		logger.Error(err)
		return nil
	}

	backend := gocv.NetBackendDefault
	target := gocv.NetTargetCPU

	model := "/Users/steven/Applications/MR4R/CAFFE_DNN/res10_300x300_ssd_iter_140000.caffemodel"
	config := "/Users/steven/Applications/MR4R/CAFFE_DNN/deploy.prototxt.txt"
	n := gocv.ReadNet(model, config)
	if n.Empty() {
		logger.Errorf("Error reading network model from : %v %v\n", model, config)
		return nil
	}
	//	defer n.Close()
	n.SetPreferableBackend(gocv.NetBackendType(backend))
	n.SetPreferableTarget(gocv.NetTargetType(target))

	imgProcessor = FaceTracker{
		metadata:        metadata,
		activityToDrone: make(map[string]tello.Drone),
		imageIn:         imageIn,
		imageOut:        imageOut,
		net:             &n,
		tracking:        true,
		detected:        false,
		detectSize:      true,
		green:           color.RGBA{0, 255, 0, 0},
		distTolerance:   0.05 * dist(0, 0, frameX, frameY),
	}

	go imgProcessor.processImage()

	return &imgProcessor
}

func (a *FaceTracker) Metadata() *activity.Metadata {
	return a.metadata
}

func (a *FaceTracker) Eval(ctx activity.Context) (done bool, err error) {
	log.Info("(FaceTracker.Eval) Entering ...")
	defer log.Info("(FaceTracker.Eval) Exit ...")

	if nil != err {
		return false, err
	}

	image, ok := ctx.GetInput("Image").(string)
	if !ok {
		return false, errors.New("Invalid Image ! ")
	}

	pkt := []byte(image)
	if _, err := a.imageIn.Write(pkt); err != nil {
		logger.Info(err)
	}

	if commandCompObj := a.getCommandsAsComplexObject(); nil != commandCompObj {
		log.Info("Commands : ", commandCompObj)
		cmds := &data.ComplexObject{Metadata: "Commands", Value: commandCompObj}
		ctx.SetOutput("Commands", cmds)
		return true, nil
	}

	return false, nil
}

func (a *FaceTracker) processImage() {
	for {
		buf := make([]byte, frameSize)
		if _, err := io.ReadFull(a.imageOut, buf); err != nil {
			logger.Info("(FaceTracker.processImage) ", err)
			continue
		}
		img, _ := gocv.NewMatFromBytes(frameY, frameX, gocv.MatTypeCV8UC3, buf)
		if img.Empty() {
			logger.Info("(FaceTracker.processImage) img.Empty()")
			continue
		} else {
			a.trackFace(&img)
		}
	}
}

func (a *FaceTracker) trackFace(frame *gocv.Mat) {
	log.Info("(FaceTracker.trackFace) enter .....")
	W := float64(frame.Cols())
	H := float64(frame.Rows())

	blob := gocv.BlobFromImage(*frame, 1.0, image.Pt(300, 300), gocv.NewScalar(104, 177, 123, 0), false, false)
	defer blob.Close()

	a.net.SetInput(blob, "data")

	detBlob := a.net.Forward("detection_out")
	defer detBlob.Close()

	detections := gocv.GetBlobChannel(detBlob, 0, 0)
	defer detections.Close()

	for r := 0; r < detections.Rows(); r++ {
		confidence := detections.GetFloatAt(r, 2)
		if confidence < 0.5 {
			log.Info("(FaceTracker.trackFace) confidence < 0.5")
			continue
		}

		a.left = float64(detections.GetFloatAt(r, 3)) * W
		a.top = float64(detections.GetFloatAt(r, 4)) * H
		a.right = float64(detections.GetFloatAt(r, 5)) * W
		a.bottom = float64(detections.GetFloatAt(r, 6)) * H

		a.left = math.Min(math.Max(0.0, a.left), W-1.0)
		a.right = math.Min(math.Max(0.0, a.right), W-1.0)
		a.bottom = math.Min(math.Max(0.0, a.bottom), H-1.0)
		a.top = math.Min(math.Max(0.0, a.top), H-1.0)

		a.detected = true
		rect := image.Rect(int(a.left), int(a.top), int(a.right), int(a.bottom))
		gocv.Rectangle(frame, rect, a.green, 3)
	}

	if !a.tracking || !a.detected {
		log.Info("(FaceTracker.trackFace) !a.tracking || !a.detected")
	}

	if a.detectSize {
		a.detectSize = false
		a.refDistance = dist(a.left, a.top, a.right, a.bottom)
	}

	distance := dist(a.left, a.top, a.right, a.bottom)

	a.commands = make([]tello.Command, 0)

	// x axis
	switch {
	case a.right < W/2:
		a.commands = append(a.commands, tello.Command{Command: tello.TurnLeft, Argument: map[string]interface{}{"speed": 50}})
	case a.left > W/2:
		a.commands = append(a.commands, tello.Command{Command: tello.TurnRight, Argument: map[string]interface{}{"speed": 50}})
	default:
		//log.Info("(FaceTracker.Eval) NOP on x axis")
	}

	// y axis
	switch {
	case a.top < H/10:
		a.commands = append(a.commands, tello.Command{Command: tello.Up, Argument: map[string]interface{}{"speed": 25}})
	case a.bottom > H-H/10:
		a.commands = append(a.commands, tello.Command{Command: tello.Down, Argument: map[string]interface{}{"speed": 25}})
	default:
		//log.Info("(FaceTracker.Eval) NOP on y axis")
	}

	// z axis
	switch {
	case distance < a.refDistance-a.distTolerance:
		a.commands = append(a.commands, tello.Command{Command: tello.Forward, Argument: map[string]interface{}{"speed": 20}})
	case distance > a.refDistance+a.distTolerance:
		a.commands = append(a.commands, tello.Command{Command: tello.Backward, Argument: map[string]interface{}{"speed": 20}})
	default:
		//log.Info("(FaceTracker.Eval) NOP on z axis")
	}
}

func dist(x1, y1, x2, y2 float64) float64 {
	return math.Sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1))
}

func (a *FaceTracker) getCommandsAsComplexObject() interface{} {
	commandArray := make([]interface{}, 0)
	for _, command := range a.commands {
		commandObject := map[string]interface{}{
			"Command":  command.Command,
			"Argument": command.Argument,
		}
		commandArray = append(commandArray, commandObject)
	}

	if 0 == len(commandArray) {
		return nil
	}

	return commandArray
}

func (a *FaceTracker) getDrone(context activity.Context) (tello.Drone, error) {
	myId := util.ActivityId(context)

	drone := a.activityToDrone[myId]
	if nil == drone {
		log.Info("(CommandSender.getDrone) Look up drone start ...")
		connection, exist := context.GetSetting(cConnection)
		if !exist {
			return nil, activity.NewError("Tello is not configured", "TELLO-CMD-SENDER-4001", nil)
		}

		connectionInfo, _ := data.CoerceToObject(connection)
		if connectionInfo == nil {
			return nil, activity.NewError("Tello connection information is unable to be parsed", "TELLO-CMD-SENDER-4002", nil)
		}

		var name string
		properties := make(map[string]interface{})
		connectionSettings, _ := connectionInfo["settings"].([]interface{})
		if connectionSettings != nil {
			for _, v := range connectionSettings {
				setting, _ := data.CoerceToObject(v)
				if setting != nil {
					if setting["name"] == cConnectionName {
						name, _ = data.CoerceToString(setting["value"])
					} else if setting["name"] == "model" {
						properties["droneModel"], _ = data.CoerceToString(setting["value"])
					} else if setting["name"] == "telloAddress" {
						properties["telloAddress"], _ = data.CoerceToString(setting["value"])
					} else if setting["name"] == "telloPort" {
						properties["telloPort"], _ = data.CoerceToInteger(setting["value"])
					} else if setting["name"] == "localPort" {
						properties["localPort"], _ = data.CoerceToInteger(setting["value"])
					}
				}
			}
			logger.Info(properties)

			var err error
			var bot interface{}
			bot, err = factory.GetBotFactory(flogobot.GobotTello).GetBot(name, properties)
			if nil != err {
				return nil, err
			}

			var ok bool
			drone, ok = bot.(tello.Drone)
			if !ok {
				return nil, errors.New("*tello.Drone is required")
			}
			a.activityToDrone[myId] = drone
		}
		log.Info("(CommandSender.getDrone) Look up Drone end ...")
	}

	return drone, nil
}
